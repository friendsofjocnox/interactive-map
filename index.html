<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Pangaea RTS Sandbox</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<style>
body { margin: 0; }
</style>
</head>
<body>

<script>
const tileSize = 32;
const cols = 30;
const rows = 20;

let grid = [];
let playerUnits = [];
let enemyUnits = [];
let selectedUnit = null;

const config = {
    type: Phaser.AUTO,
    width: cols * tileSize,
    height: rows * tileSize,
    backgroundColor: "#264653",
    scene: { preload, create, update }
};

new Phaser.Game(config);

function preload(){}

function create() {

    // Generate fictional "Pangaea" terrain
    for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {

            let blocked = Math.random() < 0.15; // 15% tiles are mountains
            grid[y][x] = blocked;

            let color = blocked ? 0x5e503f : 0x2a9d8f;

            this.add.rectangle(
                x * tileSize,
                y * tileSize,
                tileSize,
                tileSize,
                color
            ).setOrigin(0);
        }
    }

    // Spawn player units
    for (let i = 0; i < 4; i++) {
        let unit = this.add.circle(60 + i*40, 60, 10, 0x00ff00);
        unit.path = [];
        playerUnits.push(unit);
    }

    // Spawn enemies
    for (let i = 0; i < 3; i++) {
        let enemy = this.add.circle(700, 400 + i*40, 10, 0xff0000);
        enemy.path = [];
        enemyUnits.push(enemy);
    }

    // Select unit
    this.input.on('pointerdown', pointer => {
        selectedUnit = null;
        playerUnits.forEach(unit => {
            let d = Phaser.Math.Distance.Between(pointer.x, pointer.y, unit.x, unit.y);
            if (d < 15) {
                selectedUnit = unit;
                unit.setFillStyle(0xffff00);
            } else {
                unit.setFillStyle(0x00ff00);
            }
        });
    });

    // Move command (right click)
    this.input.on('pointerup', pointer => {
        if (selectedUnit && pointer.rightButtonDown()) {
            let start = worldToGrid(selectedUnit.x, selectedUnit.y);
            let end = worldToGrid(pointer.x, pointer.y);
            selectedUnit.path = findPath(start, end);
        }
    });

    this.input.mouse.disableContextMenu();
}

function update() {

    // Move player units
    playerUnits.forEach(unit => followPath(unit));

    // Enemy AI
    enemyUnits.forEach(enemy => {

        // Find closest player
        let closest = playerUnits[0];
        let dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, closest.x, closest.y);
        playerUnits.forEach(p => {
            let d = Phaser.Math.Distance.Between(enemy.x, enemy.y, p.x, p.y);
            if (d < dist) {
                closest = p;
                dist = d;
            }
        });

        // Chase player if nearby, otherwise patrol randomly
        if (dist < 1000) { // always active for demo
            let start = worldToGrid(enemy.x, enemy.y);
            let end = worldToGrid(closest.x, closest.y);
            enemy.path = findPath(start, end);
        } else if (!enemy.path || enemy.path.length === 0) {
            // Patrol to random tile
            let randomTarget = {
                x: Math.floor(Math.random() * cols),
                y: Math.floor(Math.random() * rows)
            };
            enemy.path = findPath(worldToGrid(enemy.x, enemy.y), randomTarget);
        }

        followPath(enemy);
    });
}

function followPath(unit) {
    if (!unit.path || unit.path.length === 0) return;

    let next = gridToWorld(unit.path[0]);
    let dx = next.x - unit.x;
    let dy = next.y - unit.y;
    let dist = Math.sqrt(dx*dx + dy*dy);

    if (dist < 2) {
        unit.path.shift();
    } else {
        unit.x += dx/dist * 1.5;
        unit.y += dy/dist * 1.5;
    }
}

function worldToGrid(x, y) {
    return {
        x: Math.floor(x / tileSize),
        y: Math.floor(y / tileSize)
    };
}

function gridToWorld(node) {
    return {
        x: node.x * tileSize + tileSize/2,
        y: node.y * tileSize + tileSize/2
    };
}

function findPath(start, end) {

    let open = [start];
    let cameFrom = {};
    let visited = {};

    function key(n){ return n.x + "," + n.y; }

    visited[key(start)] = true;

    while (open.length > 0) {
        let current = open.shift();

        if (current.x === end.x && current.y === end.y) {
            let path = [];
            let k = key(current);
            while (cameFrom[k]) {
                path.unshift(current);
                current = cameFrom[k];
                k = key(current);
            }
            return path;
        }

        let neighbors = [
            {x: current.x+1, y: current.y},
            {x: current.x-1, y: current.y},
            {x: current.x, y: current.y+1},
            {x: current.x, y: current.y-1}
        ];

        neighbors.forEach(n => {
            if (
                n.x >= 0 && n.x < cols &&
                n.y >= 0 && n.y < rows &&
                !grid[n.y][n.x] &&
                !visited[key(n)]
            ) {
                visited[key(n)] = true;
                cameFrom[key(n)] = current;
                open.push(n);
            }
        });
    }

    return [];
}

</script>
</body>
</html>
